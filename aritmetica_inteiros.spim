.data
	nao: .asciiz "O modulo nao eh primo.\n"
	invalido: .asciiz "Entradas invalidas.\n"

.text
    main:
		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s0, $v0 

		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s1, $v0
		
		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s2, $v0
		move $a1, $v0 # pega o N3 e passa para a1 como parametro
        jal ehPrimo  # chama funcao para verificar se é primo   

		li $s4, 0

		# $s0, (N1) (N1**N2) % N3
		# $s1, (N2)
		# $s2, (N3)
		# $s3, Resposta

		jal potencia

		div $s0, $s2 # divide o input  N por $t0, 
		mfhi $s3 # pega o resto e armazena em $t1

		li $v0, 1 # codigo para printar inteiro
		move $a0, $s3 # movendo o valor do parametro $a2 para $a0
		syscall # printando

        terminarPrograma:
            li $v0, 10 # codigo do sistema para finalizar o programa
            syscall # finalizando



	potencia:
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
		
		addi $t0, $s0, 0
		loopPotencia:
			mul $s0, $s0, $t0

			addi $s1, $s1, -1
			bgt $s1, 1, loopPotencia

		lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
		addi $sp, $sp, 4 # desalocando os 4 bytes da stack
		jr $ra

	ehPrimo:
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
        
		move $t0, $a1 # movendo o valor para $t0
		move $t1, $t0


		ble $t0, $zero, printInvalido
		beq $t0, 1, printNao

		jal sqrt

		
		li $t2, 1
		li $t3, 0

        # $t0 tem o valor de entrada
		# $t1 tem o valor da raiz quadrada da entrada
		# $t2 começa com 1 e ira iterar até o valor da raiz quadrada ( i )
		# $t3 começa com 0, e ira contar quantos divisores do numero até sua raiz quadrada
		# $t4 vai ter o resultado do resto de cada divisao no loop
		while:
			bgt $t2, $t1, breakWhile # se o valor de i for maior que a raiz quadrada, break

			div $t0, $t2 # divide o input  N por $t0, 
			mfhi $t4 # pega o resto e armazena em $t1

			beq $t4, 0, incrementaContadorDivisores

			j pulaIncremento

			incrementaContadorDivisores:
				addi $t3, $t3, 1

			pulaIncremento:
				addi $t2, $t2, 1
				j while
		breakWhile:
			beq $t3, 1, naoPrinta

		j printNao

 		printInvalido:
			li $v0, 4  # código do sitema para printar a string
			la $a0, invalido #endereço da string a imprimir no registrador $a
			syscall # printando	
			j terminarPrograma # termina o programa

 		printNao:
			# senão, printa nao
			li $v0, 4  # código do sitema para printar a string
			la $a0, nao #endereço da string a imprimir no registrador $a
			syscall # printando

		j terminarPrograma # vai para o fim da funcao

		naoPrinta:
            lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
            addi $sp, $sp, 4 # desalocando os 4 bytes da stack
            jr $ra



	sqrt:
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
        
		loopSQRT:
			div $t3, $t0, $t1   # raiz quadrada newton
			div $t5, $t3, 2      # fazendo a divisao separado para evitar overflow aritimetico
			div $t6, $t1, 2      
			add $t1, $t5, $t6   

			# voltando pro loop
			add $t4, $t4, 1 
   			blt $t4, 20, loopSQRT 

		lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
		addi $sp, $sp, 4 # desalocando os 4 bytes da stack
		jr $ra