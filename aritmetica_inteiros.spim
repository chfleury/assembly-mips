.data
	nao: .asciiz "O modulo nao eh primo.\n"
	invalido: .asciiz "Entradas invalidas.\n"
    txtUm: .asciiz "A exponencial modular "
    txtDois: .asciiz " elevado a "
    txtTres: .asciiz " (mod "
    txtQuatro: .asciiz ") eh "
    txtCinco: .asciiz ".\n"

.text
    main:
		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s0, $v0
        move $s5, $v0 

		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s1, $v0
		move $s6, $v0

		li $v0, 5  # código do sitema para leitura de inteiros
		syscall # lendo o numero
        move $s2, $v0

        jal checkEntradas # checa se entradas estao no intervalo definido

		move $a1, $v0 # pega o N3 e passa para a1 como parametro
        jal ehPrimo  # chama funcao para verificar se é primo   

		li $s4, 0

		# $s0, (N1) (N1**N2) % N3
		# $s1, (N2)
		# $s2, (N3)
		# $s3, Resposta
        # $s5, (N1) sem sofrer alterações, no mesmo jeito q foi lido
        # $s6, (N2) sem sofrer alterações, no mesmo jeito q foi lido

		jal potencia

        li $v0, 4  # código do sitema para printar a string
        la $a0, txtUm #endereço da string a imprimir no registrador $a
        syscall # printando

		li $v0, 1 # codigo para printar inteiro
		move $a0, $s5 # movendo o valor do parametro $a2 para $a0
		syscall # printando

        li $v0, 4  # código do sitema para printar a string
        la $a0, txtDois #endereço da string a imprimir no registrador $a
        syscall # printando

		li $v0, 1 # codigo para printar inteiro
		move $a0, $s6 # movendo o valor do parametro $a2 para $a0
		syscall # printando

        li $v0, 4  # código do sitema para printar a string
        la $a0, txtTres #endereço da string a imprimir no registrador $a
        syscall # printando

		li $v0, 1 # codigo para printar inteiro
		move $a0, $s2 # movendo o valor do parametro $a2 para $a0
		syscall # printando

        li $v0, 4  # código do sitema para printar a string
        la $a0, txtQuatro #endereço da string a imprimir no registrador $a
        syscall # printando

		li $v0, 1 # codigo para printar inteiro
		move $a0, $s3 # resposta
		syscall # printando

        li $v0, 4  # código do sitema para printar a string
        la $a0, txtCinco #endereço da string a imprimir no registrador $a
        syscall # printando

        terminarPrograma:
            li $v0, 10 # codigo do sistema para finalizar o programa
            syscall # finalizando


    checkEntradas:
		# addi $sp, $sp, -4 # alocando 4 bytes na stack
		# sw $ra, 0($sp) # armazenando a palvra $ra na stack

        # esse funcao checa se todas enradas sao validas
        blt $s0, 1, printInvalido
        blt $s1, 1, printInvalido
        blt $s2, 1, printInvalido

        bgt $s0, 65535, printInvalido
        bgt $s0, 65535, printInvalido
        bgt $s0, 65535, printInvalido
		# lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
		# addi $sp, $sp, 4 # desalocando os 4 bytes da stack
        jr $ra




We can easily use the above theorem such that we can get
A ^ (B ^ C) % M = (A ^ y ) %  M

Now we only need to find two things as:-


	potencia: # fazendo a funcao com base em um algoritmo de fast modular exponentiation em C
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
		
		move $t0, $s0 # b (base)
		move $t1, $s1 # e (expoente)
		move $t2, $s2 # m (modulo)

		# resultado = $s3
		li $s3, 1 #int resultado = 1;

		and $t8, $t1, 1
		bne $t8, 0, entraIf # if (1 & e)
		j loopPontencia # else
		entraIf:
			move $s3, $t0 # resultado = b
		loopPontencia:
			beq $t1, 0, fimLoopPontencia # if (!e) break
			srl $t1, $t1, 1 # e >>= 1
			mul $t0, $t0, $t0
			div $t0, $t2 # 
			mfhi $t0 # b = (b*b)%m
			and $t7, $t1, 1 #
			beq $t7, 0 , loopPontencia # if (e & 1)
			mul $s3, $s3, $t0 #
			div $s3, $t2 # 
			mfhi $s3 # resultado = (resultado * b) % m
		fimLoopPontencia:
			lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
			addi $sp, $sp, 4 # desalocando os 4 bytes da stack
			jr $ra

	ehPrimo:
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
        
		move $t0, $a1 # movendo o valor para $t0
		move $t1, $t0


		ble $t0, $zero, printInvalido 
		beq $t0, 1, printNao

		jal sqrt

		
		li $t2, 1
		li $t3, 0

        # $t0 tem o valor de entrada
		# $t1 tem o valor da raiz quadrada da entrada
		# $t2 começa com 1 e ira iterar até o valor da raiz quadrada ( i )
		# $t3 começa com 0, e ira contar quantos divisores do numero até sua raiz quadrada
		# $t4 vai ter o resultadoado do resto de cada divisao no loop
		while:
			bgt $t2, $t1, breakWhile # se o valor de i for maior que a raiz quadrada, break

			div $t0, $t2 # divide o input  N por $t0, 
			mfhi $t4 # pega o resto e armazena em $t1

			beq $t4, 0, incrementaContadorDivisores

			j pulaIncremento

			incrementaContadorDivisores:
				addi $t3, $t3, 1

			pulaIncremento:
				addi $t2, $t2, 1
				j while
		breakWhile:
			beq $t3, 1, naoPrinta

		j printNao

 		printInvalido:
			li $v0, 4  # código do sitema para printar a string
			la $a0, invalido #endereço da string a imprimir no registrador $a
			syscall # printando	
			j terminarPrograma # termina o programa

 		printNao:
			# senão, printa nao
			li $v0, 4  # código do sitema para printar a string
			la $a0, nao #endereço da string a imprimir no registrador $a
			syscall # printando

		j terminarPrograma # vai para o fim da funcao

		naoPrinta:
            lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
            addi $sp, $sp, 4 # desalocando os 4 bytes da stack
            jr $ra



	sqrt:
		addi $sp, $sp, -4 # alocando 4 bytes na stack
		sw $ra, 0($sp) # armazenando a palvra $ra na stack
        
		loopSQRT:
			div $t3, $t0, $t1   # raiz quadrada newton
			div $t5, $t3, 2      # fazendo a divisao separado para evitar overflow aritimetico
			div $t6, $t1, 2      
			add $t1, $t5, $t6   

			# voltando pro loop
			add $t4, $t4, 1 
   			blt $t4, 20, loopSQRT 

		lw $ra, 0($sp) # lendo o valor que tinhamos salvo na stack de volta para $ra 
		addi $sp, $sp, 4 # desalocando os 4 bytes da stack
		jr $ra